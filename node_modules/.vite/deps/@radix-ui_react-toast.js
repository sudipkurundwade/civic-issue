"use client";


import { __toESM } from "./chunk-DbKvDyjX.js";
import { require_react } from "./react-Dzmm40ca.js";
import { require_react_dom } from "./react-dom-Bu4ag0_3.js";
import { require_jsx_runtime } from "./jsx-runtime-B0kp3bGK.js";
import { createContextScope, useLayoutEffect2 } from "./dist-DXDcbPLQ.js";
import { useCallbackRef } from "./dist-ekl-qi4O.js";
import { useComposedRefs } from "./dist-cLE9heNo.js";
import { Primitive, dispatchDiscreteCustomEvent } from "./dist-DUSX88Qh.js";
import { Presence, composeEventHandlers } from "./dist-Cc7Gzozx.js";
import { useControllableState } from "./dist-CQzzxKAz.js";
import { Branch, Portal, Root } from "./dist-0lE-kxQv.js";
import { createCollection } from "./dist-CUg1duX4.js";
import { VisuallyHidden } from "./dist-C-Nv9sE8.js";

//#region node_modules/@radix-ui/react-toast/dist/index.mjs
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
var import_react_dom = /* @__PURE__ */ __toESM(require_react_dom(), 1);
var import_jsx_runtime = /* @__PURE__ */ __toESM(require_jsx_runtime(), 1);
var PROVIDER_NAME = "ToastProvider";
var [Collection, useCollection, createCollectionScope] = createCollection("Toast");
var [createToastContext, createToastScope] = createContextScope("Toast", [createCollectionScope]);
var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);
var ToastProvider = (props) => {
	const { __scopeToast, label = "Notification", duration = 5e3, swipeDirection = "right", swipeThreshold = 50, children } = props;
	const [viewport, setViewport] = import_react.useState(null);
	const [toastCount, setToastCount] = import_react.useState(0);
	const isFocusedToastEscapeKeyDownRef = import_react.useRef(false);
	const isClosePausedRef = import_react.useRef(false);
	if (!label.trim()) console.error(`Invalid prop \`label\` supplied to \`${PROVIDER_NAME}\`. Expected non-empty \`string\`.`);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Collection.Provider, {
		scope: __scopeToast,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ToastProviderProvider, {
			scope: __scopeToast,
			label,
			duration,
			swipeDirection,
			swipeThreshold,
			toastCount,
			viewport,
			onViewportChange: setViewport,
			onToastAdd: import_react.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
			onToastRemove: import_react.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
			isFocusedToastEscapeKeyDownRef,
			isClosePausedRef,
			children
		})
	});
};
ToastProvider.displayName = PROVIDER_NAME;
var VIEWPORT_NAME = "ToastViewport";
var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
var ToastViewport = import_react.forwardRef((props, forwardedRef) => {
	const { __scopeToast, hotkey = VIEWPORT_DEFAULT_HOTKEY, label = "Notifications ({hotkey})",...viewportProps } = props;
	const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
	const getItems = useCollection(__scopeToast);
	const wrapperRef = import_react.useRef(null);
	const headFocusProxyRef = import_react.useRef(null);
	const tailFocusProxyRef = import_react.useRef(null);
	const ref = import_react.useRef(null);
	const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
	const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
	const hasToasts = context.toastCount > 0;
	import_react.useEffect(() => {
		const handleKeyDown = (event) => {
			if (hotkey.length !== 0 && hotkey.every((key) => event[key] || event.code === key)) ref.current?.focus();
		};
		document.addEventListener("keydown", handleKeyDown);
		return () => document.removeEventListener("keydown", handleKeyDown);
	}, [hotkey]);
	import_react.useEffect(() => {
		const wrapper = wrapperRef.current;
		const viewport = ref.current;
		if (hasToasts && wrapper && viewport) {
			const handlePause = () => {
				if (!context.isClosePausedRef.current) {
					const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
					viewport.dispatchEvent(pauseEvent);
					context.isClosePausedRef.current = true;
				}
			};
			const handleResume = () => {
				if (context.isClosePausedRef.current) {
					const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
					viewport.dispatchEvent(resumeEvent);
					context.isClosePausedRef.current = false;
				}
			};
			const handleFocusOutResume = (event) => {
				if (!wrapper.contains(event.relatedTarget)) handleResume();
			};
			const handlePointerLeaveResume = () => {
				if (!wrapper.contains(document.activeElement)) handleResume();
			};
			wrapper.addEventListener("focusin", handlePause);
			wrapper.addEventListener("focusout", handleFocusOutResume);
			wrapper.addEventListener("pointermove", handlePause);
			wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
			window.addEventListener("blur", handlePause);
			window.addEventListener("focus", handleResume);
			return () => {
				wrapper.removeEventListener("focusin", handlePause);
				wrapper.removeEventListener("focusout", handleFocusOutResume);
				wrapper.removeEventListener("pointermove", handlePause);
				wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
				window.removeEventListener("blur", handlePause);
				window.removeEventListener("focus", handleResume);
			};
		}
	}, [hasToasts, context.isClosePausedRef]);
	const getSortedTabbableCandidates = import_react.useCallback(({ tabbingDirection }) => {
		const tabbableCandidates = getItems().map((toastItem) => {
			const toastNode = toastItem.ref.current;
			const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
			return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
		});
		return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
	}, [getItems]);
	import_react.useEffect(() => {
		const viewport = ref.current;
		if (viewport) {
			const handleKeyDown = (event) => {
				const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
				if (event.key === "Tab" && !isMetaKey) {
					const focusedElement = document.activeElement;
					const isTabbingBackwards = event.shiftKey;
					if (event.target === viewport && isTabbingBackwards) {
						headFocusProxyRef.current?.focus();
						return;
					}
					const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection: isTabbingBackwards ? "backwards" : "forwards" });
					const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
					if (focusFirst(sortedCandidates.slice(index + 1))) event.preventDefault();
					else isTabbingBackwards ? headFocusProxyRef.current?.focus() : tailFocusProxyRef.current?.focus();
				}
			};
			viewport.addEventListener("keydown", handleKeyDown);
			return () => viewport.removeEventListener("keydown", handleKeyDown);
		}
	}, [getItems, getSortedTabbableCandidates]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Branch, {
		ref: wrapperRef,
		role: "region",
		"aria-label": label.replace("{hotkey}", hotkeyLabel),
		tabIndex: -1,
		style: { pointerEvents: hasToasts ? void 0 : "none" },
		children: [
			hasToasts && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FocusProxy, {
				ref: headFocusProxyRef,
				onFocusFromOutsideViewport: () => {
					const tabbableCandidates = getSortedTabbableCandidates({ tabbingDirection: "forwards" });
					focusFirst(tabbableCandidates);
				}
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Collection.Slot, {
				scope: __scopeToast,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.ol, {
					tabIndex: -1,
					...viewportProps,
					ref: composedRefs
				})
			}),
			hasToasts && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FocusProxy, {
				ref: tailFocusProxyRef,
				onFocusFromOutsideViewport: () => {
					const tabbableCandidates = getSortedTabbableCandidates({ tabbingDirection: "backwards" });
					focusFirst(tabbableCandidates);
				}
			})
		]
	});
});
ToastViewport.displayName = VIEWPORT_NAME;
var FOCUS_PROXY_NAME = "ToastFocusProxy";
var FocusProxy = import_react.forwardRef((props, forwardedRef) => {
	const { __scopeToast, onFocusFromOutsideViewport,...proxyProps } = props;
	const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(VisuallyHidden, {
		tabIndex: 0,
		...proxyProps,
		ref: forwardedRef,
		style: { position: "fixed" },
		onFocus: (event) => {
			const prevFocusedElement = event.relatedTarget;
			if (!context.viewport?.contains(prevFocusedElement)) onFocusFromOutsideViewport();
		}
	});
});
FocusProxy.displayName = FOCUS_PROXY_NAME;
var TOAST_NAME = "Toast";
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var Toast = import_react.forwardRef((props, forwardedRef) => {
	const { forceMount, open: openProp, defaultOpen, onOpenChange,...toastProps } = props;
	const [open, setOpen] = useControllableState({
		prop: openProp,
		defaultProp: defaultOpen ?? true,
		onChange: onOpenChange,
		caller: TOAST_NAME
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Presence, {
		present: forceMount || open,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ToastImpl, {
			open,
			...toastProps,
			ref: forwardedRef,
			onClose: () => setOpen(false),
			onPause: useCallbackRef(props.onPause),
			onResume: useCallbackRef(props.onResume),
			onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
				event.currentTarget.setAttribute("data-swipe", "start");
			}),
			onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
				const { x, y } = event.detail.delta;
				event.currentTarget.setAttribute("data-swipe", "move");
				event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x}px`);
				event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y}px`);
			}),
			onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
				event.currentTarget.setAttribute("data-swipe", "cancel");
				event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
				event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
				event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
				event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
			}),
			onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
				const { x, y } = event.detail.delta;
				event.currentTarget.setAttribute("data-swipe", "end");
				event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
				event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
				event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x}px`);
				event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y}px`);
				setOpen(false);
			})
		})
	});
});
Toast.displayName = TOAST_NAME;
var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, { onClose() {} });
var ToastImpl = import_react.forwardRef((props, forwardedRef) => {
	const { __scopeToast, type = "foreground", duration: durationProp, open, onClose, onEscapeKeyDown, onPause, onResume, onSwipeStart, onSwipeMove, onSwipeCancel, onSwipeEnd,...toastProps } = props;
	const context = useToastProviderContext(TOAST_NAME, __scopeToast);
	const [node, setNode] = import_react.useState(null);
	const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
	const pointerStartRef = import_react.useRef(null);
	const swipeDeltaRef = import_react.useRef(null);
	const duration = durationProp || context.duration;
	const closeTimerStartTimeRef = import_react.useRef(0);
	const closeTimerRemainingTimeRef = import_react.useRef(duration);
	const closeTimerRef = import_react.useRef(0);
	const { onToastAdd, onToastRemove } = context;
	const handleClose = useCallbackRef(() => {
		if (node?.contains(document.activeElement)) context.viewport?.focus();
		onClose();
	});
	const startTimer = import_react.useCallback((duration2) => {
		if (!duration2 || duration2 === Infinity) return;
		window.clearTimeout(closeTimerRef.current);
		closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
		closeTimerRef.current = window.setTimeout(handleClose, duration2);
	}, [handleClose]);
	import_react.useEffect(() => {
		const viewport = context.viewport;
		if (viewport) {
			const handleResume = () => {
				startTimer(closeTimerRemainingTimeRef.current);
				onResume?.();
			};
			const handlePause = () => {
				const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
				closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
				window.clearTimeout(closeTimerRef.current);
				onPause?.();
			};
			viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
			viewport.addEventListener(VIEWPORT_RESUME, handleResume);
			return () => {
				viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
				viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
			};
		}
	}, [
		context.viewport,
		duration,
		onPause,
		onResume,
		startTimer
	]);
	import_react.useEffect(() => {
		if (open && !context.isClosePausedRef.current) startTimer(duration);
	}, [
		open,
		duration,
		context.isClosePausedRef,
		startTimer
	]);
	import_react.useEffect(() => {
		onToastAdd();
		return () => onToastRemove();
	}, [onToastAdd, onToastRemove]);
	const announceTextContent = import_react.useMemo(() => {
		return node ? getAnnounceTextContent(node) : null;
	}, [node]);
	if (!context.viewport) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [announceTextContent && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ToastAnnounce, {
		__scopeToast,
		role: "status",
		"aria-live": type === "foreground" ? "assertive" : "polite",
		children: announceTextContent
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ToastInteractiveProvider, {
		scope: __scopeToast,
		onClose: handleClose,
		children: import_react_dom.createPortal(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Collection.ItemSlot, {
			scope: __scopeToast,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Root, {
				asChild: true,
				onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
					if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();
					context.isFocusedToastEscapeKeyDownRef.current = false;
				}),
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.li, {
					tabIndex: 0,
					"data-state": open ? "open" : "closed",
					"data-swipe-direction": context.swipeDirection,
					...toastProps,
					ref: composedRefs,
					style: {
						userSelect: "none",
						touchAction: "none",
						...props.style
					},
					onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
						if (event.key !== "Escape") return;
						onEscapeKeyDown?.(event.nativeEvent);
						if (!event.nativeEvent.defaultPrevented) {
							context.isFocusedToastEscapeKeyDownRef.current = true;
							handleClose();
						}
					}),
					onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
						if (event.button !== 0) return;
						pointerStartRef.current = {
							x: event.clientX,
							y: event.clientY
						};
					}),
					onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
						if (!pointerStartRef.current) return;
						const x = event.clientX - pointerStartRef.current.x;
						const y = event.clientY - pointerStartRef.current.y;
						const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
						const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
						const clamp = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
						const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;
						const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;
						const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
						const delta = {
							x: clampedX,
							y: clampedY
						};
						const eventDetail = {
							originalEvent: event,
							delta
						};
						if (hasSwipeMoveStarted) {
							swipeDeltaRef.current = delta;
							handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, { discrete: false });
						} else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
							swipeDeltaRef.current = delta;
							handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, { discrete: false });
							event.target.setPointerCapture(event.pointerId);
						} else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) pointerStartRef.current = null;
					}),
					onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
						const delta = swipeDeltaRef.current;
						const target = event.target;
						if (target.hasPointerCapture(event.pointerId)) target.releasePointerCapture(event.pointerId);
						swipeDeltaRef.current = null;
						pointerStartRef.current = null;
						if (delta) {
							const toast = event.currentTarget;
							const eventDetail = {
								originalEvent: event,
								delta
							};
							if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, { discrete: true });
							else handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL, onSwipeCancel, eventDetail, { discrete: true });
							toast.addEventListener("click", (event2) => event2.preventDefault(), { once: true });
						}
					})
				})
			})
		}), context.viewport)
	})] });
});
var ToastAnnounce = (props) => {
	const { __scopeToast, children,...announceProps } = props;
	const context = useToastProviderContext(TOAST_NAME, __scopeToast);
	const [renderAnnounceText, setRenderAnnounceText] = import_react.useState(false);
	const [isAnnounced, setIsAnnounced] = import_react.useState(false);
	useNextFrame(() => setRenderAnnounceText(true));
	import_react.useEffect(() => {
		const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
		return () => window.clearTimeout(timer);
	}, []);
	return isAnnounced ? null : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Portal, {
		asChild: true,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(VisuallyHidden, {
			...announceProps,
			children: renderAnnounceText && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
				context.label,
				" ",
				children
			] })
		})
	});
};
var TITLE_NAME = "ToastTitle";
var ToastTitle = import_react.forwardRef((props, forwardedRef) => {
	const { __scopeToast,...titleProps } = props;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
		...titleProps,
		ref: forwardedRef
	});
});
ToastTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "ToastDescription";
var ToastDescription = import_react.forwardRef((props, forwardedRef) => {
	const { __scopeToast,...descriptionProps } = props;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
		...descriptionProps,
		ref: forwardedRef
	});
});
ToastDescription.displayName = DESCRIPTION_NAME;
var ACTION_NAME = "ToastAction";
var ToastAction = import_react.forwardRef((props, forwardedRef) => {
	const { altText,...actionProps } = props;
	if (!altText.trim()) {
		console.error(`Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`);
		return null;
	}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ToastAnnounceExclude, {
		altText,
		asChild: true,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ToastClose, {
			...actionProps,
			ref: forwardedRef
		})
	});
});
ToastAction.displayName = ACTION_NAME;
var CLOSE_NAME = "ToastClose";
var ToastClose = import_react.forwardRef((props, forwardedRef) => {
	const { __scopeToast,...closeProps } = props;
	const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ToastAnnounceExclude, {
		asChild: true,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.button, {
			type: "button",
			...closeProps,
			ref: forwardedRef,
			onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
		})
	});
});
ToastClose.displayName = CLOSE_NAME;
var ToastAnnounceExclude = import_react.forwardRef((props, forwardedRef) => {
	const { __scopeToast, altText,...announceExcludeProps } = props;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
		"data-radix-toast-announce-exclude": "",
		"data-radix-toast-announce-alt": altText || void 0,
		...announceExcludeProps,
		ref: forwardedRef
	});
});
function getAnnounceTextContent(container) {
	const textContent = [];
	Array.from(container.childNodes).forEach((node) => {
		if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
		if (isHTMLElement(node)) {
			const isHidden = node.ariaHidden || node.hidden || node.style.display === "none";
			const isExcluded = node.dataset.radixToastAnnounceExclude === "";
			if (!isHidden) if (isExcluded) {
				const altText = node.dataset.radixToastAnnounceAlt;
				if (altText) textContent.push(altText);
			} else textContent.push(...getAnnounceTextContent(node));
		}
	});
	return textContent;
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
	const currentTarget = detail.originalEvent.currentTarget;
	const event = new CustomEvent(name, {
		bubbles: true,
		cancelable: true,
		detail
	});
	if (handler) currentTarget.addEventListener(name, handler, { once: true });
	if (discrete) dispatchDiscreteCustomEvent(currentTarget, event);
	else currentTarget.dispatchEvent(event);
}
var isDeltaInDirection = (delta, direction, threshold = 0) => {
	const deltaX = Math.abs(delta.x);
	const deltaY = Math.abs(delta.y);
	const isDeltaX = deltaX > deltaY;
	if (direction === "left" || direction === "right") return isDeltaX && deltaX > threshold;
	else return !isDeltaX && deltaY > threshold;
};
function useNextFrame(callback = () => {}) {
	const fn = useCallbackRef(callback);
	useLayoutEffect2(() => {
		let raf1 = 0;
		let raf2 = 0;
		raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
		return () => {
			window.cancelAnimationFrame(raf1);
			window.cancelAnimationFrame(raf2);
		};
	}, [fn]);
}
function isHTMLElement(node) {
	return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates(container) {
	const nodes = [];
	const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, { acceptNode: (node) => {
		const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
		if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
		return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
	} });
	while (walker.nextNode()) nodes.push(walker.currentNode);
	return nodes;
}
function focusFirst(candidates) {
	const previouslyFocusedElement = document.activeElement;
	return candidates.some((candidate) => {
		if (candidate === previouslyFocusedElement) return true;
		candidate.focus();
		return document.activeElement !== previouslyFocusedElement;
	});
}
var Provider = ToastProvider;
var Viewport = ToastViewport;
var Root2 = Toast;
var Title = ToastTitle;
var Description = ToastDescription;
var Action = ToastAction;
var Close = ToastClose;

//#endregion
export { Action, Close, Description, Provider, Root2 as Root, Title, Toast, ToastAction, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport, Viewport, createToastScope };
//# sourceMappingURL=@radix-ui_react-toast.js.map